---
title: "2. Building analysis pipelines with `targets`"
from: markdown+emoji
code-annotations: hover
eval: false
number-sections: true
---

[Skip to exercise \>\>](#exercise)

# The `targets` package {#targets}

## What does the `targets` package do?

The `{targets}` package is a framework for building data processing, analysis and visualization pipelines in R. It helps you structure your code by splitting it onto logical chunks that follow each other in a logical order. `{targets}` also manages the intermediate results of each step, so you do not have to do it manually. It also minimizes the time it takes to update the results if any step changes, be it some change in the source data, or in the code. `{targets}` knows which steps are up-to-date, and which are not, and only runs the steps that are outdated.

Consider the following minimal example:

```r
library(targets)

list(
  # 1. Load the mtcars dataset.
  tar_target(
    name = mtcars_data,
    command = data(mtcars)
  ),

  # 2. Compute the mean of the mpg column.
  tar_target(
    name = mpg_mean,
    command = mean(mtcars_data$mpg)
  ),

  # 3. Create a histogram plot of mpg using base R.
  tar_target(
    name = hist_mpg,
    packages = c("ggplot2"),
    command = {
      ggplot(mtcars_data, aes(x = mpg)) +
        geom_histogram(binwidth = 1) +
        labs(title = "Histogram of MPG", x = "Miles Per Gallon", y = "Count")
    }
  )
)
```

This script has three steps. It loads the data, computes a simple statistic, and creates a plot. To run this pipeline with `targets` you would need to save this script to the `_targets.R` file in the root of the project directory and run `targets::tar_make()` in R console.

<details>
<summary>Code to try `targets` in R console interactively</summary>

To quickly run the pipeline above in R console without setting up `targets` properly and creating an R script file, you can use the code below, that can be pasted in to the R console (and it will make the pipeline run in a temporary directory):

```r
library(targets)
tar_dir({
  tar_script({
    library(targets)
    list(
      # Load the mtcars dataset.
      tar_target(mtcars_data, mtcars),
      
      # Compute the mean of the mpg column.
      tar_target(mpg_mean, mean(mtcars_data$mpg)),
      
      # Create a histogram plot of mpg using base R.
      # The plot is saved as a PNG file and the filename is returned.
      tar_target(plot_mpg, {
        png("hist_mpg.png")  # Open a PNG device.
        hist(mtcars_data$mpg,
             breaks = "Sturges",
             main = "Histogram of MPG",
             xlab = "Miles Per Gallon",
             ylab = "Frequency",
             col = "lightblue")
        dev.off()  # Close the device.
        "hist_mpg.png"  # Return the filename as the target value.
      })
    )
  }, ask = FALSE)
  
  # Run all targets defined in the pipeline.
  tar_make()

})
```

You will get output similar to this:

```r
▶ dispatched target mtcars_data
● completed target mtcars_data [0 seconds, 1.225 kilobytes]
▶ dispatched target plot_mpg
● completed target plot_mpg [0.011 seconds, 65 bytes]
▶ dispatched target mpg_mean
● completed target mpg_mean [0 seconds, 52 bytes]
▶ ended pipeline [0.059 seconds]
```

It would mean that all steps have been executed successfully.

Similarly, if you add `tar_visnetwork()` after `tar_make()`, you will get a visualization of the pipeline:

```r
library(targets)
tar_dir({
  tar_script({
    library(targets)
    list(
      # Load the mtcars dataset.
      tar_target(mtcars_data, mtcars),
      
      # Compute the mean of the mpg column.
      tar_target(mpg_mean, mean(mtcars_data$mpg)),
      
      # Create a histogram plot of mpg using base R.
      # The plot is saved as a PNG file and the filename is returned.
      tar_target(plot_mpg, {
        png("hist_mpg.png")  # Open a PNG device.
        hist(mtcars_data$mpg,
             breaks = "Sturges",
             main = "Histogram of MPG",
             xlab = "Miles Per Gallon",
             ylab = "Frequency",
             col = "lightblue")
        dev.off()  # Close the device.
        "hist_mpg.png"  # Return the filename as the target value.
      })
    )
  }, ask = FALSE)
  
  # Run all targets defined in the pipeline.
  tar_make()
  tar_visnetwork()
})

```

You would get output similar to the one in the @fig-mtcars-visnet below.
</details>

!["Pipeline visualization example"](media/images/mtcars-visnet.png){#fig-mtcars-visnet width=80%}

As you can see in @fig-mtcars-visnet, `{targets}` knows that the summary statistic and the plot depend on the data. If you were to change the first step of the pipeline, then the next time you ask `{targets}` to update the pipeline, it will only run steps two and three. If, however, instead of changing the data, you will change the code for the plot (e.g. change the title), then the pipeline will only re-run step three. This way, you do not have to manually keep track of what might have changed in the data or the code, or, in more complex pipelines, in the intermediate data (such as cross-validation folds for machine learning models) - `{targets}` will figure it out for you.

# Exercise {#exercise}

## Goal

The goal of this exercise is to use the project folder that you have set up in the previous exercise with `{renv}` to create a simple analysis pipeline using `{targets}`.

::: {.callout-note}
If you have not successfully completed the previous exercise, you can start the current one by downloading the repository [https://github.com/e-kotov/2025-mpidr-workflows-reference-01](https://github.com/e-kotov/2025-mpidr-workflows-reference-01){target="_blank"} and extracting it to your computer.
:::

## Instructions

## Open the project folder in your editor

Open either your own project, or our reference project snapshot form the Note above.

If you open your own project, you should see in the R console:

```r
- Project 'path/on/your/computer/to/your/project' loaded. [renv 1.1.1]
```

If you open our reference project, you should see in the R console:

```r
OK
- Installing renv  ... OK

- Project 'path/on/your/computer/2025-mpidr-workflows-reference-01' loaded. [renv 1.1.1]
- One or more packages recorded in the lockfile are not installed.
- Use `renv::status()` for more details.
```

::: {.callout-note}
The reason you will see that the packages are not installed, is because the library of R packages is specific to an operating system and is considered as a disposable storage. By default, it is not pushed to GitHub. Therefore, when you copy such project from GitHub, you don't have the packages, but you have all the files to restore the packages as required by the `renv.lock` file.
:::

## Restore (install) the R packages in the project

### In your own project

In your own project, you need to run:

```r
renv::status()
```

This is to make sure that all the packages are installed in the project. If any packages are still missing, see the step below.

### In our reference project

If you are working in our reference project from [https://github.com/e-kotov/2025-mpidr-workflows-reference-01](https://github.com/e-kotov/2025-mpidr-workflows-reference-01){target="_blank"}, you need to run:

```r
renv::restore()
```

After you confirm, you should see the package installation process.

Once the installation finishes, to make sure you have successfully installed all packages, run:

```r
renv::status()
```

You should get something like this:

```r
No issues found -- the project is in a consistent state.
```

## Setup the `{targets}` pipeline

You could of course create a `targets` pipeline manually, but there is a handy R function to initialize a template for you:

```{r}
targets::use_targets()
```

You may get:

```r
ℹ The package "usethis" is required.
✖ Would you like to install it?

1: Yes
2: No
```

Agree to that and `{renv}` will take over again to install a new package. Don't forget to add it to the `renv.lock` file with `renv::snapshot()` later.

Once this is done, you should get a new file `_targets.R` in the root of your project folder.

## Explore the sample pipeline

Before editing the `_targets.R` file, explore the pipeline that is already defined in the file.

First, run this to see the interactive graph of the pipeline (you will need to agree to install `visNetwork` package when you run this for the first time, run the command again if you still don't see the visualisation in the viewer):

```r
targets::tar_visnetwork()
```

You will see that all steps are currently outdated.

Now you can runn all the steps in the pipeline:

```r
targets::tar_make()
```

Notice that you a new folder called `_targets` is created in the project folder. This is where the output of the pipeline will be stored as well as some metadata.

If you run `targets::tar_visnetwork()` again, you will find all steps are now up-to-date.

Now you can inspect in the `R` console the results of each step. You do not need to think where each output is saved, as all outputs are always stored in the `_targets` folder and are accessible by their name. For example:

```r
tmp_object <- targets::tar_read(data)
print(tmp_object)
rm(tmp_object)
```

This will read the `data` object that is the output of the first step of the example pipeline and print it to the console. Finally, we also remove this object from the workspace to keep it clean.

You may also load the object `data` with its name directly into the workspace with:

```r
targets::tar_load(data)
```

```r
ls()
```

```r
[1] "data"
```

Now clean the workspace/environment:

```r
rm(list = ls())
```

To delete saved outputs of all or certain (see the [documentation](https://docs.ropensci.org/targets/reference/tar_destroy.html){target="_blank"}) steps, run:

```r
targets::tar_destroy()
```

To delete the saved results of steps that you might have deleted and will not use anymore, you could run:

```r
targets::tar_prune()
```

## Replace the example pipeline with data analysis pipeline

See the code in Jonas's repository at [https://github.com/jschoeley/openscience25/tree/main/layer2-communal/example_2-1](https://github.com/jschoeley/openscience25/tree/main/layer2-communal/example_2-1){target="_blank"}.

Let us try to implement the steps from his code in a `targets` pipeline. We will guide you through the first pipeline step together.

### Write code for data download step

We first need to implement the data download step found in [https://github.com/jschoeley/openscience25/blob/main/layer2-communal/example_2-1/code/10-download_input_data_from_zenodo.R](https://github.com/jschoeley/openscience25/blob/main/layer2-communal/example_2-1/code/10-download_input_data_from_zenodo.R){target="_blank"}.

We will keep all functions that implement the steps in a separate folder called `R`. Create this folder manually and create a file called `10-download_input_data_from_zenodo.R` in it. Copy the code from Jonas's repository and save it in this new file, but convert it to a function that we could call from the `targets` pipeline. Compared to Jonas's original code, this function needs to make sure that the folder for the file downloads exists and also return the paths to the downloaded data files. See the suggested function below:

```r
# Download analysis input data from Zenodo
download_files_from_zenodo <- function(
  data_folder = "data"
) {
  # make sure the data folder exists
  if (!dir.exists(data_folder)) {
    dir.create(data_folder, recursive = TRUE)
  }

  # download the files
  download.file(
    url = 'https://zenodo.org/records/15033155/files/10-euro_education.csv?download=1',
    destfile = paste0(data_folder, "/10-euro_education.csv")
  )

  download.file(
    url = 'https://zenodo.org/records/15033155/files/10-euro_sectors.csv?download=1',
    destfile = paste0(data_folder, "/10-euro_sectors.csv")
  )

  download.file(
    url = 'https://zenodo.org/records/15033155/files/10-euro_geo_nuts2.rds?download=1',
    destfile = paste0(data_folder, "/10-euro_geo_nuts2.rds")
  )

  # find the downloaded files
  data_from_zenodo <- list.files("data", full.names = TRUE)
  names(data_from_zenodo) <- basename(data_from_zenodo)

  # return the list of files
  return(data_from_zenodo)
}
```

Compare this to the original code from Jonas's repository at [https://github.com/jschoeley/openscience25/blob/main/layer2-communal/example_2-1/code/10-download_input_data_from_zenodo.R](https://github.com/jschoeley/openscience25/blob/main/layer2-communal/example_2-1/code/10-download_input_data_from_zenodo.R){target="_blank"}.

Now, to implement this first step into the pipeline, let us find the list of steps in the end of the `_targets.R` file, it's the one where all the steps are listed, each starting with `tar_target()`.

Remove all the example steps and insert your own:

```r
list(
  # download files from zenodo
  tar_target(
    name = data_from_zenodo,
    command = download_files_from_zenodo(
      data_folder = "data"
    ),
    format = "file"
  )
)
```

Notice that we have added `format = "file"` to our first step. This means that `targets` should expect not a generic `R` object like a `data.frame`, `list`, or `vector` as on output of the `download_files_from_zenodo()` function, but a vector of files. This is useful for actions such as file downloads, as `targets` will be checking on it's own if all expected files are actually downloaded.

The final step is to inform `targets` that we want to run the pipeline by executing the `targets::tar_make()`.

### Download files by executing the pipeline

Now you can run the pipeline by executing:

```r
targets::tar_make()
```

You should get something like this:

```r
▶ dispatched target data_from_zenodo
trying URL 'https://zenodo.org/records/15033155/files/10-euro_education.csv?download=1'
Content type 'text/plain; charset=utf-8' length 11150 bytes (10 KB)
==================================================
downloaded 10 KB

trying URL 'https://zenodo.org/records/15033155/files/10-euro_sectors.csv?download=1'
Content type 'text/plain; charset=utf-8' length 20626 bytes (20 KB)
================================
downloaded 20 KB

trying URL 'https://zenodo.org/records/15033155/files/10-euro_geo_nuts2.rds?download=1'
Content type 'application/octet-stream' length 261344 bytes (255 KB)
=======
downloaded 255 KB

● completed target data_from_zenodo [0.894 seconds, 293.12 kilobytes]
▶ ended pipeline [0.94 seconds]
```

The pipeline will download the files from Zenodo and will save them into the `data` folder. You can now use the downloaded files in the next steps of the pipeline.

::: {.callout-note}
One thing to try, is to manually delete any one of the downloaded files and run the `targets::tar_visnetwork()` function. You will then see that one of the steps is outdated, as `targets` knows from the first run that it needs to keep track of files and it has noted the file signatures.
:::

### Add data folder to `.gitignore`

As the data is preserved at Zenodo, and as it is bad practice to store data in the git repository, we should add the `data` folder to the `.gitignore` file. You can do this by executing the following command in the `R` console:

```r
usethis::use_git_ignore("data")
```

This will create a new `.gitignore` file in the root of the project (in case it did not exist) and add the `data` folder there. Now `git` tools will not prompt you to commit the `data` folder and it will never be pushed to GitHub or other remote repository you are using.

### `targets` settings

Feel free to remove most of the comments in the example `_targets.R` file, espetially the ones regarding the targets options. We recommend you do set the options as follows:

```r
tar_option_set(
  format = "qs"
)
```

The `qs` format is a faster and more space efficient alternative to `rds` format. You can read more about it in the [`qs2` documentation](https://github.com/qsbase/qs2?tab=readme-ov-file#single-threaded). This will be the format that `targets` uses to save the output of each step of the pipeline, unless you specify `format = 'file'`, like we did for the file list above, or set it to something else in the specicfic `tar_target()` step.

::: {.callout-note}
You might also notice that we suggest to remove the `packages` option from `tar_option_set()` that was originally there. This is because it is much safer to specify the packages you need in each `tar_target()` step individually. This might seem like a lot of work, but it it has many advatanges:

- Each step runs much faster, as unnecessary packages are not loaded.
- You can prevent potential package conflicts. In big projects with hundreds of packages, some packages may not work well when loaded simultaneously (which would happen if you specify the `packages` option globally for all steps).
- It is much easier to debug, as you can see which packages are loaded at each step.
:::

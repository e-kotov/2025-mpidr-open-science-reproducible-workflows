{
  "hash": "7f118813216ce826581cc8a51a2b92ea",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"2. Building analysis pipelines with `targets`\"\nfrom: markdown+emoji\ncode-annotations: hover\neval: false\nnumber-sections: true\n---\n\n\n\n\n-----\n\n![](media/images/blocks-targets.png)\n\n[Skip to exercise \\>\\>](#exercise)\n\n# The `targets` package {#targets}\n\n## What does the `targets` package do?\n\nThe `{targets}` package is a framework for building data processing, analysis and visualization pipelines in R. It helps you structure your code by splitting it onto logical chunks that follow each other in a logical order. `{targets}` also manages the intermediate results of each step, so you do not have to do it manually. It also minimizes the time it takes to update the results if any step changes, be it some change in the source data, or in the code. `{targets}` knows which steps are up-to-date, and which are not, and only runs the steps that are outdated.\n\nConsider the following minimal example:\n\n```r\nlibrary(targets)\n\nlist(\n  # 1. Load the mtcars dataset.\n  tar_target(\n    name = mtcars_data,\n    command = data(mtcars)\n  ),\n\n  # 2. Compute the mean of the mpg column.\n  tar_target(\n    name = mpg_mean,\n    command = mean(mtcars_data$mpg)\n  ),\n\n  # 3. Create a histogram plot of mpg using base R.\n  tar_target(\n    name = hist_mpg,\n    packages = c(\"ggplot2\"),\n    command = {\n      ggplot(mtcars_data, aes(x = mpg)) +\n        geom_histogram(binwidth = 1) +\n        labs(title = \"Histogram of MPG\", x = \"Miles Per Gallon\", y = \"Count\")\n    }\n  )\n)\n```\n\nThis script has three steps. It loads the data, computes a simple statistic, and creates a plot. To run this pipeline with `targets` you would need to save this script to the `_targets.R` file in the root of the project directory and run `targets::tar_make()` in R console.\n\n<details>\n<summary>Reveal code to try the toy `targets` example above in R console interactively</summary>\n\nTo quickly run the pipeline above in R console without setting up `targets` properly and creating an R script file, you can use the code below, that can be pasted in to the R console (and it will make the pipeline run in a temporary directory):\n\n```r\nlibrary(targets)\ntar_dir({\n  tar_script({\n    library(targets)\n    list(\n      # Load the mtcars dataset.\n      tar_target(mtcars_data, mtcars),\n      \n      # Compute the mean of the mpg column.\n      tar_target(mpg_mean, mean(mtcars_data$mpg)),\n      \n      # Create a histogram plot of mpg using base R.\n      # The plot is saved as a PNG file and the filename is returned.\n      tar_target(plot_mpg, {\n        png(\"hist_mpg.png\")  # Open a PNG device.\n        hist(mtcars_data$mpg,\n             breaks = \"Sturges\",\n             main = \"Histogram of MPG\",\n             xlab = \"Miles Per Gallon\",\n             ylab = \"Frequency\",\n             col = \"lightblue\")\n        dev.off()  # Close the device.\n        \"hist_mpg.png\"  # Return the filename as the target value.\n      })\n    )\n  }, ask = FALSE)\n  \n  # Run all targets defined in the pipeline.\n  tar_make()\n\n})\n```\n\nYou will get output similar to this:\n\n```r\n▶ dispatched target mtcars_data\n● completed target mtcars_data [0 seconds, 1.225 kilobytes]\n▶ dispatched target plot_mpg\n● completed target plot_mpg [0.011 seconds, 65 bytes]\n▶ dispatched target mpg_mean\n● completed target mpg_mean [0 seconds, 52 bytes]\n▶ ended pipeline [0.059 seconds]\n```\n\nIt would mean that all steps have been executed successfully.\n\nSimilarly, if you add `tar_visnetwork()` after `tar_make()`, you will get a visualization of the pipeline:\n\n```r\nlibrary(targets)\ntar_dir({\n  tar_script({\n    library(targets)\n    list(\n      # Load the mtcars dataset.\n      tar_target(mtcars_data, mtcars),\n      \n      # Compute the mean of the mpg column.\n      tar_target(mpg_mean, mean(mtcars_data$mpg)),\n      \n      # Create a histogram plot of mpg using base R.\n      # The plot is saved as a PNG file and the filename is returned.\n      tar_target(plot_mpg, {\n        png(\"hist_mpg.png\")  # Open a PNG device.\n        hist(mtcars_data$mpg,\n             breaks = \"Sturges\",\n             main = \"Histogram of MPG\",\n             xlab = \"Miles Per Gallon\",\n             ylab = \"Frequency\",\n             col = \"lightblue\")\n        dev.off()  # Close the device.\n        \"hist_mpg.png\"  # Return the filename as the target value.\n      })\n    )\n  }, ask = FALSE)\n  \n  # Run all targets defined in the pipeline.\n  tar_make()\n  tar_visnetwork()\n})\n\n```\n\nYou would get output similar to the one in the @fig-mtcars-visnet below.\n</details>\n\n![\"Pipeline visualization example\"](media/images/mtcars-visnet.png){#fig-mtcars-visnet width=80%}\n\nAs you can see in @fig-mtcars-visnet, `{targets}` knows that the summary statistic and the plot depend on the data. If you were to change the first step of the pipeline, then the next time you ask `{targets}` to update the pipeline, it would only run steps two and three. If, however, instead of changing the data, you changed the code for the plot (e.g. change the title), then the pipeline would only re-run step three. This way, you do not have to manually keep track of what might have changed in the data or the code, or, in more complex pipelines, in the intermediate data (such as cross-validation folds for machine learning models) - `{targets}` will figure it out for you.\n\n# Exercise {#exercise}\n\n## Goal\n\nThe goal of this exercise is to use the project folder that you have set up in the previous exercise with `{renv}` to create a simple analysis pipeline using `{targets}`.\n\n::: {.callout-note}\nIf you have not successfully completed the previous exercise, you can start the current one by downloading the repository [https://github.com/e-kotov/2025-mpidr-workflows-reference-01](https://github.com/e-kotov/2025-mpidr-workflows-reference-01){target=\"_blank\"} and extracting it to your computer.\n:::\n\n## Instructions\n\n## Open the project folder in your editor\n\nOpen either your own project, or our reference project snapshot form the Note above.\n\nIf you open your own project, you should see in the R console:\n\n```r\n- Project 'path/on/your/computer/to/your/project' loaded. [renv 1.1.1]\n```\n\nIf you open our reference project, you should see in the R console:\n\n```r\nOK\n- Installing renv  ... OK\n\n- Project 'path/on/your/computer/2025-mpidr-workflows-reference-01' loaded. [renv 1.1.1]\n- One or more packages recorded in the lockfile are not installed.\n- Use `renv::status()` for more details.\n```\n\n::: {.callout-note}\nThe reason you will see that the packages are not installed, is because the library of R packages is specific to an operating system and is considered as a disposable storage. By default, it is not pushed to GitHub. Therefore, when you copy such project from GitHub, you don't have the packages, but you have all the files to restore the packages as required by the `renv.lock` file.\n:::\n\n## Restore (install) the R packages in the project\n\n### In your own project\n\nIn your own project, you need to run:\n\n```r\nrenv::status()\n```\n\nThis is to make sure that all the packages are installed in the project. If any packages are still missing, see the step below.\n\n### In our reference project\n\nIf you are working in our reference project from [https://github.com/e-kotov/2025-mpidr-workflows-reference-01](https://github.com/e-kotov/2025-mpidr-workflows-reference-01){target=\"_blank\"}, you need to run:\n\n```r\nrenv::restore()\n```\n\nAfter you confirm, you should see the package installation process.\n\nOnce the installation finishes, to make sure you have successfully installed all packages, run:\n\n```r\nrenv::status()\n```\n\nYou should get something like this:\n\n```r\nNo issues found -- the project is in a consistent state.\n```\n\n## Setup the `{targets}` pipeline\n\nYou could of course create a `targets` pipeline manually, but there is a handy R function to initialize a template for you:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntargets::use_targets()\n```\n:::\n\n\n\n\nAgree to that and `{renv}` will take over again to install a new package. Don't forget to add it to the `renv.lock` file with `renv::snapshot()` later.\n\nOnce this is done, you should get a new file `_targets.R` in the root of your project folder.\n\n## Explore the sample pipeline\n\nBefore editing the `_targets.R` file, explore the pipeline that is already defined in the file.\n\nFirst, run this to see the interactive graph of the pipeline (you will need to agree to install `visNetwork` package when you run this for the first time, run the command again if you still don't see the visualisation in the viewer):\n\n```r\ntargets::tar_visnetwork()\n```\n\nYou will see that all steps are currently outdated.\n\nNow you can runn all the steps in the pipeline:\n\n```r\ntargets::tar_make()\n```\n\nNotice that you a new folder called `_targets` is created in the project folder. This is where the output of the pipeline will be stored as well as some metadata.\n\nIf you run `targets::tar_visnetwork()` again, you will find all steps are now up-to-date.\n\nNow you can inspect in the `R` console the results of each step. You do not need to think where each output is saved, as all outputs are always stored in the `_targets` folder and are accessible by their name. For example:\n\n```r\ntmp_object <- targets::tar_read(data)\nprint(tmp_object)\nrm(tmp_object)\n```\n\nThis will read the `data` object that is the output of the first step of the example pipeline and print it to the console. Finally, we also remove this object from the workspace to keep it clean.\n\nYou may also load the object `data` with its name directly into the workspace with:\n\n```r\ntargets::tar_load(data)\n```\n\n```r\nls()\n```\n\n```r\n[1] \"data\"\n```\n\nNow clean the workspace/environment:\n\n```r\nrm(list = ls())\n```\n\nTo delete saved outputs of all or certain (see the [documentation](https://docs.ropensci.org/targets/reference/tar_destroy.html){target=\"_blank\"}) steps, run:\n\n```r\ntargets::tar_destroy()\n```\n\nTo delete the saved results of steps that you might have deleted and will not use anymore, you could run:\n\n```r\ntargets::tar_prune()\n```\n\n## Adjust `targets` settings\n\nFeel free to remove most of the comments in the example `_targets.R` file, espetially the ones regarding the targets options. We recommend you do set the options as follows:\n\n```r\ntar_option_set(\n  format = \"qs\"\n)\n```\n\nThe `qs`/`qs2` format is a faster and more space efficient alternative to `rds` format. You can read more about it in the [`qs2` documentation](https://github.com/qsbase/qs2?tab=readme-ov-file#single-threaded). This will be the format that `targets` uses to save the output of each step of the pipeline, unless you specify `format = 'file'`, or set it to something else in the specicfic `tar_target()` step.\n\n::: {.callout-note}\nYou might also notice that we suggest to remove the `packages` option from `tar_option_set()` that was originally there. This is because it is much safer to specify the packages you need in each `tar_target()` step individually. This might seem like a lot of work, but it it has many advatanges:\n\n- Each step runs much faster, as unnecessary packages are not loaded.\n- You can prevent potential package conflicts. In big projects with hundreds of packages, some packages may not work well when loaded simultaneously (which would happen if you specify the `packages` option globally for all steps).\n- It is much easier to debug, as you can see which packages are loaded at each step.\n:::\n\nFor more `targets` options, you can see the documentation for [`tar_option_set()`](https://docs.ropensci.org/targets/reference/tar_option_set.html){target=\"_blank\"}.\n\n## Analysis step 1 - Get the data {#step1-get-data}\n\nSee the code in Jonas's repository at [https://github.com/jschoeley/openscience25/tree/main/layer2-communal/example_2-1](https://github.com/jschoeley/openscience25/tree/main/layer2-communal/example_2-1){target=\"_blank\"}.\n\nLet us try to implement the steps from his code in a `targets` pipeline. We will guide you through the first pipeline step together.\n\n### Wrap data download step into a function\n\nWe first need to implement the data download step found in [https://github.com/jschoeley/openscience25/blob/main/layer2-communal/example_2-1/code/10-download_input_data_from_zenodo.R](https://github.com/jschoeley/openscience25/blob/main/layer2-communal/example_2-1/code/10-download_input_data_from_zenodo.R){target=\"_blank\"}.\n\nWe will keep all functions that implement the steps in a separate folder called `R`. Create this folder manually and create a file called `10-download_input_data_from_zenodo.R` in it. Copy the code from Jonas's repository and save it in this new file, but convert it to a function that we could call from the `targets` pipeline. Compared to Jonas's original code, this function needs to make sure that the folder for the file downloads exists and also return the paths to the downloaded data files. See the suggested function below:\n\n```r\n# Download analysis input data from Zenodo\ndownload_files_from_zenodo <- function(\n  data_folder = \"data\"\n) {\n  # make sure the data folder exists\n  if (!dir.exists(data_folder)) {\n    dir.create(data_folder, recursive = TRUE)\n  }\n\n  # download the files\n  download.file(\n    url = 'https://zenodo.org/records/15033155/files/10-euro_education.csv?download=1',\n    destfile = paste0(data_folder, \"/10-euro_education.csv\")\n  )\n\n  download.file(\n    url = 'https://zenodo.org/records/15033155/files/10-euro_sectors.csv?download=1',\n    destfile = paste0(data_folder, \"/10-euro_sectors.csv\")\n  )\n\n  download.file(\n    url = 'https://zenodo.org/records/15033155/files/10-euro_geo_nuts2.rds?download=1',\n    destfile = paste0(data_folder, \"/10-euro_geo_nuts2.rds\")\n  )\n\n  # find the downloaded files\n  data_from_zenodo <- list.files(\"data\", full.names = TRUE)\n\n  # return the list of files\n  return(data_from_zenodo)\n}\n```\n\nCompare this to the original code from Jonas's repository at [https://github.com/jschoeley/openscience25/blob/main/layer2-communal/example_2-1/code/10-download_input_data_from_zenodo.R](https://github.com/jschoeley/openscience25/blob/main/layer2-communal/example_2-1/code/10-download_input_data_from_zenodo.R){target=\"_blank\"}.\n\nNow, to implement this first step into the pipeline, let us find the list of steps in the end of the `_targets.R` file, it's the one where all the steps are listed, each starting with `tar_target()`.\n\nRemove all the example steps and insert your own:\n\n```r\nlist(\n  # download files from zenodo\n  tar_target(\n    name = data_from_zenodo,\n    command = download_files_from_zenodo(\n      data_folder = \"data\"\n    ),\n    format = \"file\"\n  )\n)\n```\n\nNotice that we have added `format = \"file\"` to our first step. This means that `targets` should expect not a generic `R` object like a `data.frame`, `list`, or `vector` as on output of the `download_files_from_zenodo()` function, but a vector of files. This is useful for actions such as file downloads, as `targets` will be checking on it's own if all expected files are actually downloaded.\n\nThe final step is to inform `targets` that we want to run the pipeline by executing the `targets::tar_make()`.\n\n### Download files by executing the pipeline\n\nNow you can run the pipeline by executing:\n\n```r\ntargets::tar_make()\n```\n\nYou should get something like this:\n\n```r\n▶ dispatched target data_from_zenodo\ntrying URL 'https://zenodo.org/records/15033155/files/10-euro_education.csv?download=1'\nContent type 'text/plain; charset=utf-8' length 11150 bytes (10 KB)\n==================================================\ndownloaded 10 KB\n\ntrying URL 'https://zenodo.org/records/15033155/files/10-euro_sectors.csv?download=1'\nContent type 'text/plain; charset=utf-8' length 20626 bytes (20 KB)\n================================\ndownloaded 20 KB\n\ntrying URL 'https://zenodo.org/records/15033155/files/10-euro_geo_nuts2.rds?download=1'\nContent type 'application/octet-stream' length 261344 bytes (255 KB)\n=======\ndownloaded 255 KB\n\n● completed target data_from_zenodo [0.894 seconds, 293.12 kilobytes]\n▶ ended pipeline [0.94 seconds]\n```\n\nThe pipeline downloaded the files from Zenodo and will save them into the `data` folder. You can now use the downloaded files in the next steps of the pipeline.\n\nMake an interactive graph of the pipeline:\n\n```r\ntargets::tar_visnetwork()\n```\n\n\nYou should see a network similar to the one in @fig-ex-02-targets-zenodo-data.png.\n\n![\"Up to date workflow including getting the data and producing the basemap\"](media/images/ex-02-targets-zenodo-data.png){#fig-ex-02-targets-zenodo-data.png}\n\n\n\n::: {.callout-note}\nOne thing to try, is to manually delete any one of the downloaded files and run the `targets::tar_visnetwork()` function. You will then see that one of the steps is outdated, as `targets` knows from the first run that it needs to keep track of files and it has noted the file signatures.\n:::\n\n### Add data folder to `.gitignore`\n\nAs the data is preserved at Zenodo, and as it is bad practice to store data in the git repository, we should add the `data` folder to the `.gitignore` file. You can do this by executing the following command in the `R` console:\n\n```r\nusethis::use_git_ignore(\"data\")\n```\n\nThis will create a new `.gitignore` file in the root of the project (in case it did not exist) and add the `data` folder there. Now `git` tools will not prompt you to commit the `data` folder and it will never be pushed to GitHub or other remote repository you are using.\n\n\n\n## Analysis step 2 - Create background map\n\nNow let us add a new step that creates background map that will be re-used in all of the plots me can create following the code in Jonas's repository. We will look at the code in [https://github.com/jschoeley/openscience25/blob/main/layer2-communal/example_2-1/code/20-create_european_backgroundmap.R](https://github.com/jschoeley/openscience25/blob/main/layer2-communal/example_2-1/code/20-create_european_backgroundmap.R){target=\"_blank\"} and adjust it to be a `targets` step executed by `tar_target()`.\n\nBecause the code there uses [`_config.yaml`](https://github.com/jschoeley/openscience25/blob/main/layer2-communal/example_2-1/code/_config.yaml){target=\"_blank\"} to customize the plots, you will need to [download](https://github.com/jschoeley/openscience25/raw/refs/heads/main/layer2-communal/example_2-1/code/_config.yaml){target=\"_blank\"} it and put into your project, e.g. into `config` folder.\n\nWe will also break down the code into steps, as it makes sense to isolate the code for downloading the data from Natural Earth into a separate function.\n\n#### Step 2.1 Download Natural Earth data\n\nLook at [the corresponding lines](https://github.com/jschoeley/openscience25/blob/9efc85e2dad9b2d1cc05da2d257c5dad01a97276/layer2-communal/example_2-1/code/20-create_european_backgroundmap.R#L28C1-L42C39){target=\"_blank\"} in Jonas's code:\n\n```r\n# Download Eurasian geodata ---------------------------------------\neura_sf <-\n  # download geospatial data for European, Asian and African countries\n  ne_countries(continent = c('europe', 'asia', 'africa'),\n               returnclass = 'sf', scale = 10) %>%\n  # project to crs suitable for Europe\n  st_transform(crs = config$crs) %>%\n  # merge into single polygon\n  st_union(by_feature = FALSE) %>%\n  # crop to Europe\n  st_crop(xmin = config$eurocrop$xmin,\n          xmax = config$eurocrop$xmax,\n          ymin = config$eurocrop$ymin,\n          ymax = config$eurocrop$ymax)\n```\n\nWe will rewrite it as a following function:\n\n```r\n# Download Eurasian geodata ---------------------------------------\ndownload_ne_data <- function(\n  crs, xmin, xmax, ymin, ymax\n) {\n  eura_sf <-\n    # download geospatial data for European, Asian and African countries\n    rnaturalearth::ne_countries(\n      continent = c('europe', 'asia', 'africa'),\n      returnclass = 'sf',\n      scale = 10\n    ) |>\n    # project to crs suitable for Europe\n    sf::st_transform(crs = crs) |>\n    # merge into single polygon\n    sf::st_union(by_feature = FALSE) |>\n    # crop to Europe\n    sf::st_crop(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax)\n\n  return(eura_sf)\n}\n```\n\nAs you can see, we got rid of the references to `yaml` file, which is one of the ways to approach it. Any preferences previously set in yaml file are now set in the function parameters.\n\nWe also prefixed each function call with a package name. We do this to be more aware of which packages we use in each function to minimize the potential for conflicts.\n\nIn the list of `targets` steps we will add the call as follows:\n\n```r\ntar_target(\n  name = eura_sf,\n  packages = c(\"rnaturalearth\", \"sf\"),\n  command = download_ne_data(\n    crs = 3035,\n    xmin = 25.0e+5,\n    xmax = 75.0e+5,\n    ymin = 13.5e+5,\n    ymax = 54.5e+5\n  )\n)\n```\n\nNote that:\n\n- We specified the `packages` argument for an individual target step.\n- We did not specify the `format = \"file\"`, so by default it will be `qs2` format, as specified above in `tar_option_set()`.\n\n::: {.callout-note}\nAs you might have noticed, we set the name of the `targets` step as `eura_sf`, and we also return an object called `eura_sf` from the `download_ne_data()` function. These names do NOT have to match, as in larger projects functions may be reused multiple times and they may have more generic uses and therefore return different output to different targets based on their input parameters. In this case, we are just naming the objects in the same way for convenience.\n:::\n\nTest the `targets` pipeline by running it and making an interactive graph:\n\n```r\ntargets::tar_make()\ntargets::tar_visnetwork()\n```\n\nYou should see a network similar to the one in @fig-ex-02-targets-ne-data.\n\n![\"Up to date workflow including getting the data and producing the basemap\"](media/images/ex-02-targets-ne-data.png){#fig-ex-02-targets-ne-data}\n\n\n\n\n## Step 2.2 Wrap background map creation step into a function\n\nCreate a file `20-create_european_backgroundmap.R` in `R` subfolder of your project.\n\nLook at [the first few lines](https://github.com/jschoeley/openscience25/blob/9efc85e2dad9b2d1cc05da2d257c5dad01a97276/layer2-communal/example_2-1/code/20-create_european_backgroundmap.R#L15-L26){target=\"_blank\"} in Jonas's code, just after the `library()` calls (which we will look at later).\n\nOriginal lines:\n\n```r\n# input and output paths\npaths <- list()\npaths$input <- list(\n  config = './code/_config.yaml'\n  \n)\npaths$output <- list(\n  euro_basemap.rds = './data/20-euro_basemap.rds'\n)\n\n# global configuration\nconfig <- read_yaml(paths$input$config)\n```\n\nWe do not nede to use any of these lines anymore. Previously we had to specify where to save the base map in `paths$output`. With `targets`, we do not need to manually keep track where we save intermediate results and wether or not they are up to date. Instead of saving the file at the path specified in `paths$output`, we will just return an `R` object from the function called by a particular `targets` step and it will be stored automatically for us in `_targets/objects` folder. We do not need the `_config.yaml` here anymore, as it did not contain any variables that would affect the basemap creation.\n\nWe only need [the lines](https://github.com/jschoeley/openscience25/blob/9efc85e2dad9b2d1cc05da2d257c5dad01a97276/layer2-communal/example_2-1/code/20-create_european_backgroundmap.R#L44C1-L53C15){target=\"_blank\"} that create a `ggplot2` plot object with the basemap:\n\n```r\n# Draw a basemap of Europe ----------------------------------------\neuro_basemap <-\n  ggplot(eura_sf) +\n  geom_sf(\n    aes(geometry = geometry),\n    color = NA, fill = 'grey90'\n  ) +\n  coord_sf(expand = FALSE, datum = NA) +\n  theme_void()\n```\n\nAnd we rewrite these as a function:\n\n```r\n# Draw a basemap of Europe ----------------------------------------\ncreate_european_backgroundmap <- function(\n  eura_sf\n) {\n  # eura_sf <- targets::tar_read(eura_sf) # for debug\n\n  euro_basemap <-\n    ggplot2::ggplot(eura_sf) +\n    ggplot2::geom_sf(\n      aes(geometry = geometry),\n      color = NA,\n      fill = 'grey90'\n    ) +\n    ggplot2::coord_sf(expand = FALSE, datum = NA) +\n    ggplot2::theme_void()\n\n  return(euro_basemap)\n}\n```\n\nNotice that we pass `eura_sf` object that we created with `targets` step that executed `download_ne_data()` and we return the `ggplot2` object `euro_basemap` that should be reused in the next steps for creating the maps.\n\nWe also added explicit `ggplot2::` prefixes to relevant functions. This is optional, as we will specify that we need `ggplot2` package for this function in the `targets` pipeline, but this also helps to debug the function quickly.\n\nTo run the code in this function manually, you can use the commented out line `eura_sf <- targets::tar_read(eura_sf)` to quickly load the `eura_sf` object (assuming you have previously ran the `targets` pipeline and it is saved in the `targets/ojects` storage).\n\nNow let us add a `targets` step to the pipeline:\n\n```r\ntar_target(\n  name = euro_basemap,\n  packages = c(\"ggplot2\"),\n  command = create_european_backgroundmap(\n    eura_sf = eura_sf\n  )\n)\n```\n\nTest the targets pipeline by running it and making an interactive graph:\n\n```r\ntargets::tar_make()\ntargets::tar_visnetwork()\n```\n\nYou should see a network similar to the one in @fig-ex-02-targets-eubasemap-done.\n\n![\"Up to date workflow including getting the data and producing the basemap\"](media/images/ex-02-targets-eubasemap-done.png){#fig-ex-02-targets-eubasemap-done}\n\nNow if you run `targets::tar_read(euro_basemap)`, you should get a plot of the basemap (see @fig-ex-02-targets-euro-basemap):\n\n![The figure to be expected as output of `targets::tar_read(euro_basemap)`](media/images/ex-02-targets-euro-basemap.png){#fig-ex-02-targets-euro-basemap}\n\n## Next steps\n\nNow you it is up to you to adapt the code from one of the R scripts that create maps (`30-plot_figure_1.R`, `31-plot_figure_2.R`, `32-plot_figure_3.R`) in Jonas's repository at [https://github.com/jschoeley/openscience25/tree/main/layer2-communal/example_2-1/code](https://github.com/jschoeley/openscience25/tree/main/layer2-communal/example_2-1/code){target=\"_blank\"}. in the same way we did above. We would suggest that because these plots are final output images, instead of returning `ggplot2` objects from the plot making functions, you save the plots to files and return the path to the file, like we did with the [step that downloaded the data from Zenodo](#step1-get-data).\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}